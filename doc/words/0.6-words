
string-ext string search-order-ext search-order tools-ext tools 
memory-alloc-ext memory-alloc locals-ext locals floating-ext floating 
file-ext file facility-ext facility exception-ext exception double-ext 
double block-ext block max-float os-class wordlists #locals 
floating-stack stack-cells return-stack-cells gforth MAX-UD MAX-D MAX-U 
MAX-N FLOORED CORE-EXT CORE /PAD /HOLD /COUNTED-STRING MAX-CHAR 
ADDRESS-UNIT-BITS 
init-callbacks va-ret callback; callback callbacks (float) (void) 
(int) rettype symbol, decl, arg, arg@ argtype init-shared-libs 
library proc: legacy-proc proc, @proc @lib cb-decl c-decl legacy 
revarg revdec thislib thisproc libs object :: new defines end-class 
class var method interface interface-does> object bind static dynamic 
o[] o> >o o@ ^ ostack Objects 8aligned define? heap-new dict-new 
xt-new init-object object equal print construct [parent] [current] 
current' [bind] bind bind' <bind> [to-inst] <to-inst> inst-value 
do-inst-value inst-var do-inst-var inst-something catch ;m exitm :m 
m: enterm to-this this implementation front-extend-mem end-class 
end-class-noname end-methods drop-order class-previous remove-class-order 
class methods push-order class>order add-class-order public protected 
public-wordlist end-interface end-interface-noname interface 
last-interface-offset overrides class-override! unique-interface-map 
class->map interface-override! selector method do-interface-method 
do-class-method no-method current-interface selector% selector-interface 
selector-offset class% class-inst-size class-wordlist class-parent 
interface% interface-offset interface-map-offset interface-map object% 
object-map disasm disassembler base-addr show-name default-32bit 
default-16bit default-16bit? col w@ (D.) MAXCOUNTED SPCS SPCS-MAX 
maxstring end-code ;code (;code) code init-asm assembler break" 
(break") break: (break:) break:, dbg (debug) (_debug) D-KEY Unnest 
Nesting nestXT nestXT-checkSpecial Body restore-bp set-bp DT BP 
breaker DebugLoop jump get-next disp-step Leave-D NoFine d.s .n 
scanword restore-see-flags save-see-flags dbg-ip simple-see 
simple-see-range print-backtrace print-bt-entry backtrace-return-stack 
init-backtrace backtrace-rs-buffer adjust-buffer init-buffer buffer% 
buffer-maxlength buffer-address buffer-length buffer-descriptor c-extend1 
c-lp+!# c-laddr# c-f@local# c-flit c-@local# c-branch-lp+!# 
c-?branch-lp+!# c-loop-lp+!# see name-see (.immediate) (xt-see-xt) 
xt-see seefield seecol seedoes see-threaded seedefer seevalue seecon 
seeuser seevar seecode next-prim umin next-head discode .defname 
xt-see-xt makepass c-init analyse BranchTo? DoTable c-extender C-Table 
c-(compile) c-does> c-abort" c-exit c-?do c-do c-loop c-for c-?branch 
DebugBranch c-branch RepeatCheck Forward? c-string? c-c" .name-without 
c-lit+ c-lit c-callxt c-call .word back? Debug? Display? Scan? 
DebugMode DisplayMode ScanMode C-Pass NoOutput Branch! Type! ,Branch 
CheckWhile MyBranch CheckEnd MoreBranchAddr? BranchAddr? (BranchAddr?) 
FirstBranch MaxTable BranchTable SearchPointer BranchPointer Branches 
C-Stop LeaveCode Disable WhileCode2 AheadCode ElseCode UntilCode 
AgainCode RepeatCode .struc c-\type (.string) .string cemit ctype 
c-to-upper warp? (nl) nl nlcount uppercase nlflag level- level+ 
Format Level YPos XPos C-Clearline C-Highlight C-Formated C-Output 
.\" s\" \"-parse \-escape \-escape-table parse-num parse-num-x char/ 
ekey? ekey>char ekey clear-ekey-buffer esc-sequence esc-prefix #esc 
ekey-buffered ekey-buffer esc-sequences unkeys unkey char-append-buffer 
key-buffered key-buffer s-k12 s-k11 s-k10 s-k9 s-k8 s-k7 s-k6 s-k5 
s-k4 s-k3 s-k2 s-k1 k12 k11 k10 k9 k8 k7 k6 k5 k4 k3 k2 k1 
k-delete k-insert k-next k-prior k-end k-home k-down k-up k-right 
k-left keycode table tablesearch-map table-find savesystem dump-fi 
update-image-included-files save-string-dict <compilation compilation> 
(compilation>) <interpretation interpretation> (interpretation>) 
fix-does-code create-interpret/compile no-interpretation-does-code 
no-compilation-does-code bye block-included --> +thru +load thru load 
block-input list updated? scr buffer block get-buffer flush 
empty-buffers save-buffers empty-buffer save-buffer update 
block-position get-block-fid use open-blocks flush-blocks block-cold 
offset block-offset block-fid block-limit buffers last-block 
block-buffers buffer-struct next-buffer block-buffer buffer-dirty 
buffer-fid buffer-block ) (end-assert) assert( assert3( assert2( 
assert1( assert0( assertn assert-level vt100-decode tcode trans: 
transcode translate history-cold get-history kill-prefix tab-expand 
tib-full? kill-expand search-prefix prefix-string search-voc word-lex 
capscomp sgn prefix-found extract-word end-pos first-pos (enter) lfpad 
prev-line find-prev-line next-line get-line hist-setpos hist-pos 
clear-tib clear-line history-file force-open end^ backward^ forward^ 
history bindkey eof <del> forw back (ret) ?del (ins) (del) 
type-rest >string ctrl O-PNT@ O-DEINIT O-INIT TypeXT EmitXT O-EMIT 
O-TYPE O-PNT O-Buffer page at-xy ESC[ ;pn pn WordInfo InfoTable 
Com# Str# Ali# Use# Col# Def# Doe# Val# Var# Con# Pri# prim? 
xtprim? colon? defered? does? user? con? var? alias? >head >name 
threaded>name look prim>name PrimStart threaded>xt search-name 
xt>threaded f.rdp f>str-rdp f>buf-rdp f>buf-rdp-try push-right ]] 
postponer [[ compile-literal slurp-fid slurp-file const-does> 
(const-does>) compile-fliterals compile-literals in-return-stack? ]L sh 
system $? dmax dmin ?CSP !CSP CSP needs locals| TO definer! 
>definer (local) (exit-like) (until-like) (again-like) (begin-like) 
(then-like) locals-;-hook locals-:-hook endscope adjust-locals-list 
scope { old-dpp new-locals-wl new-locals-map new-locals-reveal 
new-locals-find locals-types lp-offset, lp-offset create-local 
compile-pushlocal-c compile-pushlocal-d compile-pushlocal-f check-begin 
set-locals-size-list list-size sub-list? common-list compile-pushlocal-w 
alignlp-f alignlp-w locals-dp locals-buffer locals adjust-locals-size 
compile-lp+! compile-f@local compile-@local f.s f~ f~rel f~abs 1/f 
f2/ f2* pi fvariable sfnumber ~~ (.debugline) .debugline 
printdebugdata .sourcepos compile-sourcepos str>loadfilename# 
loadfilename#>str fs. fe. f. f$ -zeros zeros scratch set-precision 
precision FLiteral fdepth fconstant f, dfloat+ sfloat+ dfalign 
sfalign .words hash-cold make-hash (hashsearch-map) hashdouble (rehash) 
rehashall clearhash addall inithash hash-reveal (reveal lastlink! 
hash-find bucket NewFix DelFix hash-alloc hashsearch-map HashTable 
HashPop HashIndex HashPointer revealed insRule hash Hashlen hashbits 
reserve-mem marker marker! marker, included-files-mark expect span 
search blank erase convert [compile] C" endcase endof of case m*/ 
d>s 2Literal .( broken-pipe-error exception next-exception errstring 
has? $has? e? environment? environment-wordlist environment vocs order 
.voc .name .id id. seal set-order get-order init-vp 
update-image-order Only Root Forth vocsearch (localsvocfind) 
locals-wordlist (vocfind) previous also >order check-maxvp Vocabulary 
wordlist mappedwordlist slowvoc definitions vp! set-current get-current 
vp maxvp-limit maxvp %alloc %allocate %allot %align %size %alignment 
double% sfloat% dfloat% float% char% cell% struct end-struct field 
create-field field, dozerofield nalign naligned endtry recover 
(recover) try (try) store-backtrace 'throw 'catch dodoes: dofield: 
dodefer: douser: dovar: docol: docon: vlist words wordlist-words cols 
rows ? dump .line .chars .4 /dump .s maxdepth-.s [WHILE] [AGAIN] 
[REPEAT] [UNTIL] [BEGIN] [I] [NEXT] [FOR] [LOOP] [+LOOP] [?DO] [DO] 
(i) [ENDIF] [THEN] [ELSE] [IFUNDEF] [IFDEF] [IF] [undefined] defined 
[defined] ?if [struct]-voc [struct]-search scanIF >exec dummy countif 
." S" abort" SLiteral CLiteral ?EXIT EXIT exit-like NEXT S+LOOP 
-LOOP +LOOP LOOP loop-like FOR U-DO -DO U+DO +DO ?DO ?do-like DO 
?LEAVE LEAVE DONE leave> >leave clear-leave-stack leave-sp leave-stack 
leave-stack-size REPEAT WHILE UNTIL until-like AGAIN again-like BEGIN 
begin-like ELSE ENDIF THEN cs>addr then-like ?DUP-0=-IF ?DUP-IF IF 
AHEAD YET BUT <resolve >resolve >mark sys? ?struc cs-push-orig 
cs-push-part CS-ROLL CS-PICK cs-item-size cs-item? non-orig? scope? 
do-dest? dest? orig? def? scopestart do-dest dest dead-orig live-orig 
ASSUME-LIVE UNREACHABLE backedge-locals dead-code locals-list .included 
.strings require include required included included1 add-included-file 
included? init-included-files sourceline# sourcefilename 
image-included-files included-files open-fpath-file open-path-file 
check-path open-ofile reworkdir compact.. expandtopic remove~+ 
extractpath need/ pathsep? tfile ofile absolut-path? .fpath .path 
previous-path next-path path>counted fpath= path= fpath+ path+ 
only-path clear-path also-path os-cold fpath +place path-allot ( 
write-line bin r/o r/w w/o os-boot (process-args) do-option script? 
argc argv pathdirs pathstring #! arg cstring>sstring license 
include-file execute-parsing-file execute-parsing-named-file read-loop 
query clear-tibstack evaluate execute-parsing create-input restore-input 
save-input pop-file push-file expand-tib new-tib file-input read-line 
evaluate-input terminal-input tib+ tib loadfilename #fill-bytes blk 
loadfile loadline old-input max#tib #tib >in (restore-input) 
(save-input) source-id refill source input-var input-method accept 
edit-line decode everychar insert-char ctrlkeys (ret) (bs) (ins) 
recursive rehash reveal check-shadow warnings (reveal) last? ; 
:noname : (:noname) defstart ;-hook :-hook interpret/compile? What's 
TO IS [IS] <IS> DOES> Defers Defer interpret/compile: 
interpret/compile-struct interpret/compile-comp interpret/compile-int 
(Field) 2Constant AValue Value AConstant Constant (Constant) AUser 
User uallot 2Variable AVariable Variable Create Alias compile-only 
restrict immediate lastflags ctoggle creset cset ," mem, S, ] [ 
compiler recurse POSTPONE postpone, [COMP'] COMP' ['] [(')] name>comp 
(compile) dodoes, (does>) !does compile-to-prims, peephole-compile, 
basic-block-end compile, cfa, [char] char ALiteral Literal latest 
lastxt latestxt noname noname-header nextname nextname-header 
nextname-string input-stream input-stream-header header, longstring, 
string, header (header) const A, cfalign maxalign falign align 2, , 
c, allot bye boot cold init8 'cold process-args bootmessage 
(bootmessage) quit (DoError) .error-frame .error-string dobacktrace 
DOERROR -trailing typewhite hex. dec.r dec. >error error> error-stack 
max-errors (quit) prompt .status 'quit extend-mem free-mem-var 
save-mem interpreter interpret interpret1 no.extensions 
interpreter-notfound compiler-notfound name parse-word parser ' (') 
find sfind find-name search-wordlist (search-wordlist) /does-handler 
does-handler! does-code! code-address! >does-code >code-address body> 
>body >head-noprim head? ??? (name>intn) (name>comp) name?int name>int 
(name>x) ((name>)) name>string (x>int) (cfa>int) compile-only-error 
ticking-compile-only-error flag-sign lcount-mask restrict-mask 
immediate-mask alias-mask context voclink current lookup forth-wordlist 
f83search initvoc f83find wordlist-struct wordlist-extend wordlist-link 
wordlist-id wordlist-map wordlist-map-struct hash-method rehash-method 
reveal-method find-method \G \ ( number number? snumber? s>number 
s>number? s>unumber? sign? getbase bases name-too-long? name-too-short? 
(name) parse word sword (word) chainperform chained linked 
version-string .error >stderr ErrLink u. . ud. d. u.r .r ud.r d.r 
#s # sign #>> <<# #> <# hold pad backspaces spaces space cr bell 
#lf #ff #cr #del #tab #bs #bell (S") (.") key? key emit type 
(key?) (key) (emit) (type) infile-id outfile-id hex decimal */ */mod 
"lit clearstack depth ?stack abort (abort") c(abort") throw catch 
lp@ ud/mod s>d >number accumulate digit? skip scan bounds place 
roll dabs off on here dp in-dictionary? unused usable-dictionary-end 
dictionary-end A! chars cfaligned maxaligned r@ NIL str< 
string-prefix? str= locals-size max-name-length last-compiled-here 
last-compiled Last LastCFA dpp normal-dp state dpl base current-input 
"error errorhandler backtrace-rp0 backtrace-empty handler l0 lp0 fp0 
r0 rp0 s0 sp0 save-task prev-task next-task udp main-task def#tib 
pad-minsize holdend holdptr holdbuf-end holdbuf word-pno-size 
chars/block l/s c/l /line bl float cell false true forthstart 
image-header tag-offsets call2 set-next-code decompile-prim 
forget-dyncode finish-code compile-prim1 va-return-double va-return-float 
va-return-longlong va-return-ptr va-return-int va-return-void 
va-arg-double va-arg-float va-arg-ptr va-arg-longlong va-arg-int 
va-start-double va-start-float va-start-ptr va-start-longlong 
va-start-int va-start-void alloc-callback av-call-ptr av-call-longlong 
av-call-double av-call-float av-call-int av-call-void av-ptr-r 
av-longlong-r av-double-r av-float-r av-int-r av-ptr av-longlong 
av-double av-float av-int av-start-ptr av-start-longlong av-start-double 
av-start-float av-start-int av-start-void wcall lib-sym open-lib fpick 
f>l >l lp! lp+2 lp+ lp- lp+!# laddr# f@local1 f@local0 f@local# 
@local3 @local2 @local1 @local0 @local# faxpy v* dfaligned sfaligned 
dfloats sfloats fatanh facosh fasinh ftanh fcosh fsinh ftan fsqrt 
fsincos fsin falog flog flnp1 fln fexpm1 fexp fcos fatan2 fatan 
fasin facos fabs >float represent fmin fmax fround floor floats 
float+ ftuck fnip frot fover fswap fdup fdrop fnegate f** f/ f* 
f- f+ sf! sf@ df! df@ f@ f! f>d d>f f0>= f0<= f0> f0< f0<> f0= 
f>= f<= f> f< f<> f= cputime utime newline filename-match close-dir 
read-dir open-dir file-eof? file-status flush-file emit-file write-file 
(read-line) read-file resize-file file-size reposition-file 
file-position rename-file delete-file create-file open-file close-file 
call-c strsignal strerror resize free allocate ms time&date 
close-pipe open-pipe getenv (system) (bye) flush-icache form stderr 
stdout stdin key?-file key-file threading-method faligned aligned 
(parse-white) (hashkey1) (tablelfind) (hashlfind) (listlfind) count 
(chars) char+ cells cell+ 2@ 2! c! c@ +! ! lit@ @ 2tuck 2nip 
2rot 2swap 2over 2dup 2drop pick ?dup tuck nip -rot rot dup swap 
drop over 2rdrop 2r@ 2r> 2>r rdrop r> >r fp! fp@ rp! rp@ sp! 
sp@ up! useraddr within du>= du<= du> du< du<> du= d0>= d0<= d0> 
d0< d0<> d0= d>= d<= d> d< d<> d= u>= u<= u> u< u<> u= >= <= 
> < <> = 0>= 0<= 0> 0< 0<> 0= lshift rshift invert xor or and 
d2/ d2* dnegate d- d+ m+ um/mod um* m* sm/rem fm/mod 2/ 2* /mod 
mod / * abs min max 1- 1+ negate - under+ lit+ + lit /string 
toupper compare fill cmove> cmove move k j i' i (u-do) (-do) 
(u+do) (+do) (?do) (do) (for) (s+loop)-lp+!# (s+loop) (-loop)-lp+!# 
(-loop) (+loop)-lp+!# (+loop) (loop)-lp+!# (loop) (next)-lp+!# (next) 
?dup-0=-?branch ?dup-?branch ?branch-lp+!# ?branch branch branch-lp+!# 
does-exec lit-perform unloop ;s perform execute call noop 
-- } ( \ C^ C: D^ D: F^ F: W^ W: 